
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib import messages
from .models import CaseType, Branch, BranchCaseType, Bank, Employee, Case, CaseUpdate
                        parent_case=parent
                    )
                    
                    # Create a case update entry for the additional case
                    CaseUpdate.objects.create(
                        case=new_case,
                        action="additional_case_created",
                        remark=f"Additional case created from parent case {parent.case_number}",
                        updated_by=employee
                    )eUpdate
from django.utils import timezone
from django.db.models import Count
from .forms import (
    CaseTypeForm, BranchForm, BranchCaseTypeForm, BankForm, EmployeeForm, EmployeeEditForm,
    CaseCreationForm, CaseAssignmentForm, CaseWorkForm, AdditionalCaseAddressForm, CaseActionForm
)
from .decorators import admin_required, advocate_or_admin_required, get_user_employee, check_case_access

# Case Management Views
@admin_required
def create_case(request):
    if request.method == 'POST':
        form = CaseCreationForm(request.POST)
        if form.is_valid():
            case = form.save(commit=False)
            
            # Set status based on advocate assignment
            if case.assigned_advocate:
                case.status = 'pending'
                messages.success(request, f'Case {case.case_number} created and assigned to {case.assigned_advocate.name}')
            else:
                case.status = 'pending_assignment'
                messages.success(request, f'Case {case.case_number} created and added to pending assignment.')
            
            case.save()
                
            return redirect('view_cases')
    else:
        form = CaseCreationForm()
    
    return render(request, 'cases/create_case.html', {'form': form})

@advocate_or_admin_required
def view_cases(request):
    employee = get_user_employee(request.user)
    
    # Check if user is in admin groups or is superuser
    is_admin = request.user.groups.filter(name__in=['ADMIN', 'CO-ADMIN']).exists() or request.user.is_superuser
    
    if is_admin:
        # Only admin users can see all cases
        cases = Case.objects.select_related('bank', 'case_type', 'assigned_advocate').all().order_by('-created_at')
    elif employee and employee.employee_type == 'advocate':
        # Advocates only see their assigned cases
        cases = Case.objects.filter(assigned_advocate=employee).select_related('bank', 'case_type', 'assigned_advocate').order_by('-created_at')
    else:
        # Other users (should not happen with the decorator) see no cases
        cases = Case.objects.none()

    # Bucket definitions (cannot declare tuple literals inside template tags)
    # Group 1: Pending Assignment Section
    pending_assignment_buckets = [
        ('Pending Assignment', 'pending_assignment', 'orange'),
    ]
    
    # Group 2: Pending Section
    pending_buckets = [
        ('Pending', 'pending', 'purple'),
    ]
    
    # Group 3: Hold, Query, Document Pending Section
    active_buckets = [
        ('On Hold', 'on_hold', 'blue'),
        ('On Query', 'on_query', 'yellow'),
        ('Document Pending', 'document_pending', 'indigo'),
    ]
    
    # Group 4: Completed Sections
    completed_positive_buckets = [
        ('Positive', 'positive', 'emerald'),
    ]
    
    completed_negative_buckets = [
        ('Negative', 'negative', 'red'),
    ]

    # Status counts for quick access in template
    all_buckets = pending_assignment_buckets + pending_buckets + active_buckets + completed_positive_buckets + completed_negative_buckets
    status_counts = {s: 0 for s in [b[1] for b in all_buckets]}
    for c in cases:
        if c.status in status_counts:
            status_counts[c.status] += 1

    return render(
        request,
        'cases/view_cases.html',
        {
            'cases': cases,
            'active_buckets': active_buckets,
            'pending_buckets': pending_buckets,
            'pending_assignment_buckets': pending_assignment_buckets,
            'completed_positive_buckets': completed_positive_buckets,
            'completed_negative_buckets': completed_negative_buckets,
            'status_counts': status_counts,
            'is_admin': request.user.groups.filter(name__in=['ADMIN', 'CO-ADMIN']).exists() or request.user.is_superuser,
        }
    )

@advocate_or_admin_required
def advocate_cases_filtered(request, filter_type):
    employee = get_user_employee(request.user)
    is_admin = request.user.groups.filter(name__in=['ADMIN','CO-ADMIN']).exists() or request.user.is_superuser
    qs = Case.objects.all()
    title = 'All Cases'
    if employee and employee.employee_type == 'advocate' and not is_admin:
        qs = qs.filter(assigned_advocate=employee)
    status_map = {
        'active': ['on_hold','on_query','document_pending'],
        'pending': ['pending'],
        'pending_assignment': ['pending_assignment'],
        'document_pending': ['document_pending'],
        'query': ['on_query'],
        'hold': ['on_hold'],
        'doc_hold': ['document_pending'],
        'completed': ['positive','negative'],
        'hold_query_doc': ['on_hold','on_query','document_pending']
    }
    if filter_type in status_map:
        qs = qs.filter(status__in=status_map[filter_type])
        title = filter_type.replace('_',' ').title() + ' Cases'
    cases = qs.select_related('bank','case_type','assigned_advocate').order_by('-updated_at')

    # Reuse same bucket data so template works identically
    # Group 1: Pending Assignment Section
    pending_assignment_buckets = [
        ('Pending Assignment', 'pending_assignment', 'orange'),
    ]
    
    # Group 2: Pending Section
    pending_buckets = [
        ('Pending', 'pending', 'purple'),
    ]
    
    # Group 3: Hold, Query, Document Pending Section
    active_buckets = [
        ('On Hold', 'on_hold', 'blue'),
        ('On Query', 'on_query', 'yellow'),
        ('Document Pending', 'document_pending', 'indigo'),
    ]
    
    # Group 4: Completed Sections
    completed_positive_buckets = [
        ('Positive', 'positive', 'emerald'),
    ]
    
    completed_negative_buckets = [
        ('Negative', 'negative', 'red'),
    ]

    # Status counts for quick access in template
    all_buckets = pending_assignment_buckets + pending_buckets + active_buckets + completed_positive_buckets + completed_negative_buckets
    status_counts = {s: 0 for s in [b[1] for b in all_buckets]}
    for c in cases:
        if c.status in status_counts:
            status_counts[c.status] += 1

    return render(
        request,
        'cases/view_cases.html',
        {
            'cases': cases,
            'list_title': title,
            'active_buckets': active_buckets,
            'pending_buckets': pending_buckets,
            'pending_assignment_buckets': pending_assignment_buckets,
            'completed_positive_buckets': completed_positive_buckets,
            'completed_negative_buckets': completed_negative_buckets,
            'status_counts': status_counts,
            'is_admin': is_admin,
        }
    )

@admin_required
def view_pending_cases(request):
    """View cases that are pending assignment (no documents or no advocate)"""
    pending_cases = Case.objects.filter(
        status__in=['pending_assignment', 'document_pending']
    ).select_related('bank', 'case_type', 'assigned_advocate').order_by('-created_at')
    
    return render(request, 'cases/view_pending_cases.html', {'cases': pending_cases})

@admin_required
def assign_case_advocate(request, case_id):
    """Assign an advocate to a case when documents become available"""
    case = get_object_or_404(Case, id=case_id)
    
    if request.method == 'POST':
        form = CaseAssignmentForm(request.POST, instance=case)
        if form.is_valid():
            case = form.save()
            messages.success(request, f'Case {case.case_number} assigned to {case.assigned_advocate.name}')
            return redirect('view_pending_cases')
    else:
        form = CaseAssignmentForm(instance=case)
    
    return render(request, 'cases/assign_case_advocate.html', {'form': form, 'case': case})

@advocate_or_admin_required
def case_detail(request, case_id):
    """View detailed information about a case"""
    case = get_object_or_404(Case, id=case_id)
    
    # Check if user has access to this case
    if not check_case_access(request.user, case):
        messages.error(request, "You don't have permission to view this case.")
        return redirect('view_cases')
    
    # Get the timeline entries for this case
    timeline_entries = CaseUpdate.objects.filter(case=case).order_by('-update_date')
    
    return render(request, 'cases/case_detail.html', {
        'case': case,
        'timeline_entries': timeline_entries
    })

def case_timeline(request, case_id):
    """Display a timeline of all actions taken on a case."""
    case = get_object_or_404(Case, id=case_id)
    
    # Check if user has permission to view this case
    if not check_case_access(request.user, case):
        messages.error(request, "You don't have permission to view this case.")
        return redirect('view_cases')
    
    # Get all updates for this case, ordered by most recent first
    timeline_entries = CaseUpdate.objects.filter(case=case).order_by('-update_date')
    
    return render(request, 'cases/case_timeline.html', {
        'case': case,
        'timeline_entries': timeline_entries
    })

@advocate_or_admin_required
def work_on_case(request, case_id):
    """Advocate fills in working details and can add additional property cases.
    Creating additional cases clones key meta from parent but different property address."""
    case = get_object_or_404(Case, id=case_id)
    if not check_case_access(request.user, case):
        messages.error(request, "You don't have permission to edit this case.")
        return redirect('view_cases')

    extra_address_forms = []
    extra_count = int(request.POST.get('extra_count', '0')) if request.method == 'POST' else 1

    if request.method == 'POST':
        form = CaseWorkForm(request.POST, instance=case)
        # build dynamic forms
        for i in range(extra_count):
            prefix = f'addr_{i}'
            address_value = request.POST.get(f'{prefix}_property_address', '').strip()
            if address_value:  # Only create forms for non-empty addresses
                extra_form = AdditionalCaseAddressForm({
                    'property_address': address_value
                })
                extra_address_forms.append(extra_form)
            # Skip empty address forms completely

        # Add validation debugging
        if not form.is_valid():
            messages.error(request, f"Form errors: {form.errors}")
        
        for i, ef in enumerate(extra_address_forms):
            if not ef.is_valid():
                messages.error(request, f"Extra form {i+1} errors: {ef.errors}")
                
        all_valid = form.is_valid() and all(f.is_valid() for f in extra_address_forms)
        if all_valid:
            # Get the employee associated with the current user
            try:
                employee = Employee.objects.get(user=request.user)
            except Employee.DoesNotExist:
                employee = None
                
            parent = form.save()
            
            # Create a case update entry for the work done
            CaseUpdate.objects.create(
                case=parent,
                action="case_details_updated",
                remark="Case details have been updated",
                updated_by=employee
            )
            
            # create child cases
            for f in extra_address_forms:
                addr = f.cleaned_data.get('property_address', '').strip()
                if addr:  # Double-check that we have an address
                    new_case = Case.objects.create(
                        applicant_name=parent.applicant_name,
                        case_number=f"{parent.case_number}-{parent.child_cases.count()+1}",
                        bank=parent.bank,
                        case_type=parent.case_type,
                        documents_present=parent.documents_present,
                        assigned_advocate=parent.assigned_advocate,
                        status='pending',
                        property_address=addr,
                        state=parent.state,
                        district=parent.district,
                        tehsil=parent.tehsil,
                        branch=parent.branch,
                        reference_name=parent.reference_name,
                        case_name=parent.case_name,
                        employee=parent.employee,
                        parent_case=parent
                    )
                    
                    # Create a case update entry for the additional case
                    CaseUpdate.objects.create(
                        case=new_case,
                        action="additional_case_created",
                        remark=f"Additional case created from parent case {parent.case_number}",
                        updated_by=employee
                    )
            messages.success(request, 'Case details saved and additional cases created (if any).')
            return redirect('case_detail', case_id=case.id)
    else:
        form = CaseWorkForm(instance=case)
        extra_address_forms = [AdditionalCaseAddressForm()]  # start with one blank

    return render(request, 'cases/work_on_case.html', {
        'form': form,
        'extra_forms': extra_address_forms,
        'extra_count': len(extra_address_forms),
        'case': case
    })

@advocate_or_admin_required
def case_action(request, case_id):
    case = get_object_or_404(Case, id=case_id)
    if not check_case_access(request.user, case):
        messages.error(request, "You don't have permission to act on this case.")
        return redirect('view_cases')

    if request.method == 'POST':
        form = CaseActionForm(request.POST)
        
        # Add debugging for form errors
        if not form.is_valid():
            for field, errors in form.errors.items():
                for error in errors:
                    messages.error(request, f"Error in {field}: {error}")
            
        if form.is_valid():
            action = form.cleaned_data['action']
            remark_text = form.cleaned_data.get('remark')
            forward = form.cleaned_data.get('forward_to_sro', False)

            # Block finalization actions until details complete
            if action in ['positive','negative'] and not case.has_complete_details():
                messages.error(request, 'Fill all case details (address, state, district, tehsil, branch, reference name, case name) before marking Positive or Negative.')
                return redirect('work_on_case', case_id=case.id)

            # Map actions to statuses
            status_map = {
                'query': 'on_query',
                'hold': 'on_hold',
                'document_hold': 'document_pending',
                'positive': 'positive',
                'negative': 'negative'
            }
            # Debug status mapping
            if action not in status_map:
                messages.error(request, f"Unknown action type: {action}")
                return render(request, 'cases/case_action.html', {'form': form, 'case': case})
                
            case.status = status_map[action]

            if action in ['positive','negative']:
                # Ensure legal reference numbers for case and its family (parent + children or siblings) when completing
                def finalize(c: Case):
                    c.generate_legal_reference_number()
                    c.completed_at = timezone.now()
                    c.status = 'positive' if action == 'positive' else 'negative'
                    c.save()
                # Gather related (family) cases
                related_cases = []
                if case.parent_case:  # current is a child
                    root = case.parent_case
                    related_cases = [root] + list(root.child_cases.all())
                else:  # current is root
                    related_cases = [case] + list(case.child_cases.all())
                # Remove duplicates just in case
                seen = set()
                unique_related = []
                for rc in related_cases:
                    if rc.id not in seen:
                        seen.add(rc.id)
                        unique_related.append(rc)

                # Validate all have complete details + state (needed for reference number)
                missing_detail = [rc.case_number for rc in unique_related if not rc.has_complete_details() or not rc.state]
                if missing_detail:
                    messages.error(request, f"Cannot finalize. Fill all required details for: {', '.join(missing_detail)} before marking {action}.")
                    return redirect('work_on_case', case_id=case.id)

                # Finalize all
                for rc in unique_related:
                    finalize(rc)
                messages.success(request, f"{action.title()} applied to cases: {', '.join([rc.case_number for rc in unique_related])}.")
            if action == 'negative' and forward:
                case.forwarded_to_sro = True
            case.save()

            # Get the employee associated with the current user
            try:
                employee = Employee.objects.get(user=request.user)
            except Employee.DoesNotExist:
                employee = None
                
            if remark_text:
                CaseUpdate.objects.create(case=case, action=action, remark=remark_text, updated_by=employee)
            else:
                CaseUpdate.objects.create(case=case, action=action, updated_by=employee)
            messages.success(request, f'Action {action} applied to case {case.case_number}.')
            return redirect('case_detail', case_id=case.id)
    else:
        form = CaseActionForm()
    return render(request, 'cases/case_action.html', {'form': form, 'case': case})

@admin_required
def view_branches_by_bank(request, pk):
    bank = get_object_or_404(Bank, pk=pk)
    branches = Branch.objects.filter(bank=bank)
    return render(request, 'cases/view_branches.html', {'branches': branches, 'selected_bank': bank})

@admin_required
def create_bank(request):
    if request.method == 'POST':
        form = BankForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('view_banks')
    else:
        form = BankForm()
    return render(request, 'cases/create_bank.html', {'form': form})

@admin_required
def view_banks(request):
	banks = Bank.objects.all()
	return render(request, 'cases/view_banks.html', {'banks': banks})

@admin_required
def edit_bank(request, pk):
	bank = get_object_or_404(Bank, pk=pk)
	if request.method == 'POST':
		form = BankForm(request.POST, instance=bank)
		if form.is_valid():
			form.save()
			return redirect('view_banks')
	else:
		form = BankForm(instance=bank)
	return render(request, 'cases/create_bank.html', {'form': form})


@admin_required
def delete_bank(request, pk):
	bank = get_object_or_404(Bank, pk=pk)
	if request.method == 'POST':
		bank.delete()
		return redirect('view_banks')
	return render(request, 'cases/delete_bank_confirm.html', {'bank': bank})

@admin_required
def create_branch(request):
	bank_id = request.GET.get('bank')
	
	if request.method == 'POST':
		form = BranchForm(request.POST)
		if form.is_valid():
			branch = form.save()
			if 'bank_id' in request.POST and request.POST['bank_id']:
				return redirect('view_branches_by_bank', pk=request.POST['bank_id'])
			return redirect('view_branches')
	else:
		initial = {}
		if bank_id:
			try:
				bank = Bank.objects.get(pk=bank_id)
				initial = {'bank': bank}
			except Bank.DoesNotExist:
				pass
		form = BranchForm(initial=initial)
	
	banks = Bank.objects.all()
	return render(request, 'cases/create_branch.html', {'form': form, 'banks': banks, 'bank_id': bank_id})

@admin_required
def view_branches(request):
	branches = Branch.objects.select_related('bank').all()
	return render(request, 'cases/view_branches.html', {'branches': branches})

@admin_required
def edit_branch(request, pk):
	branch = get_object_or_404(Branch, pk=pk)
	bank_id = branch.bank.pk
	
	if request.method == 'POST':
		form = BranchForm(request.POST, instance=branch)
		if form.is_valid():
			branch = form.save()
			return redirect('view_branches_by_bank', pk=branch.bank.pk)
	else:
		form = BranchForm(instance=branch)
	
	return render(request, 'cases/create_branch.html', {'form': form, 'edit_mode': True, 'bank_id': bank_id})

@admin_required
def delete_branch(request, pk):
	branch = get_object_or_404(Branch, pk=pk)
	bank_id = branch.bank.pk
	
	if request.method == 'POST':
		branch.delete()
		return redirect('view_branches_by_bank', pk=bank_id)
	
	return render(request, 'cases/delete_branch_confirm.html', {'branch': branch})

@admin_required
def assign_case_type(request, pk):
	branch = get_object_or_404(Branch, pk=pk)
	if request.method == 'POST':
		form = BranchCaseTypeForm(request.POST)
		if form.is_valid():
			branch_case_type = form.save(commit=False)
			branch_case_type.branch = branch
			branch_case_type.save()
			return redirect('view_branches_by_bank', pk=branch.bank.pk)
	else:
		form = BranchCaseTypeForm()
	return render(request, 'cases/assign_case_type.html', {'form': form, 'branch': branch})

@admin_required
def create_case_type(request):
	if request.method == 'POST':
		form = CaseTypeForm(request.POST)
		if form.is_valid():
			form.save()
			return redirect('dashboard')
	else:
		form = CaseTypeForm()
	return render(request, 'cases/create_case_type.html', {'form': form})


@admin_required
def view_case_types(request):
	case_types = CaseType.objects.all()
	return render(request, 'cases/view_case_types.html', {'case_types': case_types})

@admin_required
def delete_case_type(request, pk):
	case_type = get_object_or_404(CaseType, pk=pk)
	if request.method == 'POST':
		case_type.delete()
		return redirect('view_case_types')
	return render(request, 'cases/delete_case_type_confirm.html', {'case_type': case_type})

@admin_required
def edit_branch_case_type(request, pk):
	branch_case_type = get_object_or_404(BranchCaseType, pk=pk)
	if request.method == 'POST':
		form = BranchCaseTypeForm(request.POST, instance=branch_case_type)
		if form.is_valid():
			form.save()
			return redirect('view_branches_by_bank', pk=branch_case_type.branch.bank.pk)
	else:
		form = BranchCaseTypeForm(instance=branch_case_type)
	return render(request, 'cases/assign_case_type.html', {'form': form, 'branch': branch_case_type.branch, 'edit_mode': True})

@admin_required
def delete_branch_case_type(request, pk):
	branch_case_type = get_object_or_404(BranchCaseType, pk=pk)
	bank_id = branch_case_type.branch.bank.pk
	if request.method == 'POST':
		branch_case_type.delete()
		return redirect('view_branches_by_bank', pk=bank_id)
	return render(request, 'cases/delete_branch_case_type_confirm.html', {'branch_case_type': branch_case_type})


@admin_required
def create_case_type(request):
	if request.method == 'POST':
		form = CaseTypeForm(request.POST)
		if form.is_valid():
			form.save()
			return redirect('dashboard')
	else:
		form = CaseTypeForm()
	return render(request, 'cases/create_case_type.html', {'form': form})


@login_required
def view_case_types(request):
	case_types = CaseType.objects.all()
	return render(request, 'cases/view_case_types.html', {'case_types': case_types})


@login_required
def edit_branch_case_type(request, pk):
	branch_case_type = get_object_or_404(BranchCaseType, pk=pk)
	if request.method == 'POST':
		form = BranchCaseTypeForm(request.POST, instance=branch_case_type)
		if form.is_valid():
			form.save()
			return redirect('view_branches_by_bank', pk=branch_case_type.branch.bank.pk)
	else:
		form = BranchCaseTypeForm(instance=branch_case_type)
	return render(request, 'cases/assign_case_type.html', {'form': form, 'branch': branch_case_type.branch, 'edit_mode': True})


@login_required
def delete_branch_case_type(request, pk):
	branch_case_type = get_object_or_404(BranchCaseType, pk=pk)
	bank_id = branch_case_type.branch.bank.pk
	if request.method == 'POST':
		branch_case_type.delete()
		return redirect('view_branches_by_bank', pk=bank_id)
	return render(request, 'cases/delete_branch_case_type_confirm.html', {'branch_case_type': branch_case_type})


@admin_required
def delete_case(request, case_id):
    """Delete a case and its child cases (if any)"""
    case = get_object_or_404(Case, id=case_id)
    
    if request.method == 'POST':
        # Capture information before deletion for message
        case_number = case.case_number
        has_children = case.child_cases.exists()
        child_count = case.child_cases.count()
        
        # If this is a child case, redirect to the parent after deletion
        parent_id = case.parent_case.id if case.parent_case else None
        
        # Delete the case (cascade will handle child cases)
        case.delete()
        
        if has_children:
            messages.success(request, f'Case {case_number} and {child_count} related cases deleted successfully.')
        else:
            messages.success(request, f'Case {case_number} deleted successfully.')
        
        # Redirect to parent case detail if this was a child case
        if parent_id:
            return redirect('case_detail', case_id=parent_id)
        else:
            return redirect('view_cases')
    
    return render(request, 'cases/delete_case_confirm.html', {'case': case})
